//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package net.mstjr.murmur.proxy.server;

import net.mstjr.murmur.helpers.CertificateListHelper;
import net.mstjr.murmur.helpers.UserInfoMapHelper;
import net.mstjr.murmur.proxy.Meta;
import net.mstjr.murmur.proxy.callback.ServerCallback;
import net.mstjr.murmur.proxy.callback.ServerContextCallback;
import net.mstjr.murmur.proxy.server.users.UserInfo;

/**
 * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
 * If an added callback ever throws an exception or goes away, it will be automatically removed.
 * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
 * synchronously. If the response lags, the entire murmur server will lag.
 * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
 * deadlock the server.
 **/
public interface ServerAuthenticator extends com.zeroc.Ice.Object
{
    /**
     * Holds the result of operation authenticate.
     **/
    class AuthenticateResult
    {
        /**
         * Default constructor.
         **/
        public AuthenticateResult()
        {
        }

        /**
         * This constructor makes shallow copies of the results for operation Authenticate.
         * @param returnValue UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough),
         * -3 for authentication failures where the data could (temporarily) not be verified.
         * @param newname Set this to change the username from the supplied one.
         * @param groups List of groups on the root channel that the user will be added to for the duration of the connection.
         **/
        public AuthenticateResult(int returnValue, String newname, String[] groups)
        {
            this.returnValue = returnValue;
            this.newname = newname;
            this.groups = groups;
        }

        /**
         * UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough),
         * -3 for authentication failures where the data could (temporarily) not be verified.
         **/
        public int returnValue;
        /**
         * Set this to change the username from the supplied one.
         **/
        public String newname;
        /**
         * List of groups on the root channel that the user will be added to for the duration of the connection.
         **/
        public String[] groups;

        public void write(com.zeroc.Ice.OutputStream ostr)
        {
            ostr.writeString(this.newname);
            ostr.writeStringSeq(this.groups);
            ostr.writeInt(returnValue);
        }

        public void read(com.zeroc.Ice.InputStream istr)
        {
            this.newname = istr.readString();
            this.groups = istr.readStringSeq();
            returnValue = istr.readInt();
        }
    }

    /**
     * Holds the result of operation getInfo.
     **/
    class GetInfoResult
    {
        /**
         * Default constructor.
         **/
        public GetInfoResult()
        {
        }

        /**
         * This constructor makes shallow copies of the results for operation GetInfo.
         * @param returnValue true if information is present, false to fall through.
         * @param info Information about user. This needs to include at least "name".
         **/
        public GetInfoResult(boolean returnValue, java.util.Map<UserInfo, String> info)
        {
            this.returnValue = returnValue;
            this.info = info;
        }

        /**
         * true if information is present, false to fall through.
         **/
        public boolean returnValue;
        /**
         * Information about user. This needs to include at least "name".
         **/
        public java.util.Map<UserInfo, String> info;

        public void write(com.zeroc.Ice.OutputStream ostr)
        {
            UserInfoMapHelper.write(ostr, this.info);
            ostr.writeBool(returnValue);
        }

        public void read(com.zeroc.Ice.InputStream istr)
        {
            this.info = UserInfoMapHelper.read(istr);
            returnValue = istr.readBool();
        }
    }

    /**
     * Called to authenticate a user. If you do not know the username in question, always return -2 from this
     * method to fall through to normal database authentication.
     * Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
     * the username and id so it cannot be used for normal database authentication.
     * The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
     * should only be trusted if certstrong is true.
     *
     * Internally, Murmur treats usernames as case-insensitive. It is recommended
     * that authenticators do the same. Murmur checks if a username is in use when
     * a user connects. If the connecting user is registered, the other username is
     * kicked. If the connecting user is not registered, the connecting user is not
     * allowed to join the server.
     * @param name Username to authenticate.
     * @param pw Password to authenticate with.
     * @param certificates List of der encoded certificates the user connected with.
     * @param certhash Hash of user certificate, as used by murmur internally when matching.
     * @param certstrong True if certificate was valid and signed by a trusted CA.
     * @param current The Current object for the invocation.
     * @return An instance of ServerAuthenticator.AuthenticateResult.
     **/
    AuthenticateResult authenticate(String name, String pw, byte[][] certificates, String certhash, boolean certstrong, com.zeroc.Ice.Current current);

    /**
     * Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
     * want murmur to take care of this information itself, simply return false to fall through.
     * @param id User id.
     * @param current The Current object for the invocation.
     * @return An instance of ServerAuthenticator.GetInfoResult.
     **/
    GetInfoResult getInfo(int id, com.zeroc.Ice.Current current);

    /**
     * Map a name to a user id.
     * @param name Username to map.
     * @param current The Current object for the invocation.
     * @return User id or -2 for unknown name.
     **/
    int nameToId(String name, com.zeroc.Ice.Current current);

    /**
     * Map a user id to a username.
     * @param id User id to map.
     * @param current The Current object for the invocation.
     * @return Name of user or empty string for unknown id.
     **/
    String idToName(int id, com.zeroc.Ice.Current current);

    /**
     * Map a user to a custom Texture.
     * @param id User id to map.
     * @param current The Current object for the invocation.
     * @return User texture or an empty texture for unknown users or users without textures.
     **/
    byte[] idToTexture(int id, com.zeroc.Ice.Current current);

    /** @hidden */
    String[] _iceIds =
    {
        "::Ice::Object",
        "::Murmur::ServerAuthenticator"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::Murmur::ServerAuthenticator";
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_authenticate(ServerAuthenticator obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        String iceP_name;
        String iceP_pw;
        byte[][] iceP_certificates;
        String iceP_certhash;
        boolean iceP_certstrong;
        iceP_name = istr.readString();
        iceP_pw = istr.readString();
        iceP_certificates = CertificateListHelper.read(istr);
        iceP_certhash = istr.readString();
        iceP_certstrong = istr.readBool();
        inS.endReadParams();
        AuthenticateResult ret = obj.authenticate(iceP_name, iceP_pw, iceP_certificates, iceP_certhash, iceP_certstrong, current);
        com.zeroc.Ice.OutputStream ostr = inS.startWriteParams();
        ret.write(ostr);
        inS.endWriteParams(ostr);
        return inS.setResult(ostr);
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_getInfo(ServerAuthenticator obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        int iceP_id;
        iceP_id = istr.readInt();
        inS.endReadParams();
        GetInfoResult ret = obj.getInfo(iceP_id, current);
        com.zeroc.Ice.OutputStream ostr = inS.startWriteParams();
        ret.write(ostr);
        inS.endWriteParams(ostr);
        return inS.setResult(ostr);
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_nameToId(ServerAuthenticator obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        String iceP_name;
        iceP_name = istr.readString();
        inS.endReadParams();
        int ret = obj.nameToId(iceP_name, current);
        com.zeroc.Ice.OutputStream ostr = inS.startWriteParams();
        ostr.writeInt(ret);
        inS.endWriteParams(ostr);
        return inS.setResult(ostr);
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_idToName(ServerAuthenticator obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        int iceP_id;
        iceP_id = istr.readInt();
        inS.endReadParams();
        String ret = obj.idToName(iceP_id, current);
        com.zeroc.Ice.OutputStream ostr = inS.startWriteParams();
        ostr.writeString(ret);
        inS.endWriteParams(ostr);
        return inS.setResult(ostr);
    }

    /**
     * @hidden
     * @param obj -
     * @param inS -
     * @param current -
     * @return -
    **/
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceD_idToTexture(ServerAuthenticator obj, final com.zeroc.IceInternal.Incoming inS, com.zeroc.Ice.Current current)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, current.mode);
        com.zeroc.Ice.InputStream istr = inS.startReadParams();
        int iceP_id;
        iceP_id = istr.readInt();
        inS.endReadParams();
        byte[] ret = obj.idToTexture(iceP_id, current);
        com.zeroc.Ice.OutputStream ostr = inS.startWriteParams();
        ostr.writeByteSeq(ret);
        inS.endWriteParams(ostr);
        return inS.setResult(ostr);
    }

    /** @hidden */
    String[] _iceOps =
    {
        "authenticate",
        "getInfo",
        "ice_id",
        "ice_ids",
        "ice_isA",
        "ice_ping",
        "idToName",
        "idToTexture",
        "nameToId"
    };

    /** @hidden */
    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutputStream> _iceDispatch(com.zeroc.IceInternal.Incoming in, com.zeroc.Ice.Current current)
        throws com.zeroc.Ice.UserException
    {
        int pos = java.util.Arrays.binarySearch(_iceOps, current.operation);
        if(pos < 0)
        {
            throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        switch(pos)
        {
            case 0:
            {
                return _iceD_authenticate(this, in, current);
            }
            case 1:
            {
                return _iceD_getInfo(this, in, current);
            }
            case 2:
            {
                return com.zeroc.Ice.Object._iceD_ice_id(this, in, current);
            }
            case 3:
            {
                return com.zeroc.Ice.Object._iceD_ice_ids(this, in, current);
            }
            case 4:
            {
                return com.zeroc.Ice.Object._iceD_ice_isA(this, in, current);
            }
            case 5:
            {
                return com.zeroc.Ice.Object._iceD_ice_ping(this, in, current);
            }
            case 6:
            {
                return _iceD_idToName(this, in, current);
            }
            case 7:
            {
                return _iceD_idToTexture(this, in, current);
            }
            case 8:
            {
                return _iceD_nameToId(this, in, current);
            }
        }

        assert(false);
        throw new com.zeroc.Ice.OperationNotExistException(current.id, current.facet, current.operation);
    }
}
