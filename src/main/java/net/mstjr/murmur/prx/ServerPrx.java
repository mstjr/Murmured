//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package net.mstjr.murmur.prx;

import net.mstjr.murmur.exceptions.*;
import net.mstjr.murmur.exceptions.invalid.*;
import net.mstjr.murmur.exceptions.server.ServerBootedException;
import net.mstjr.murmur.exceptions.server.ServerFailureException;
import net.mstjr.murmur.helpers.*;
import net.mstjr.murmur.logging.LogEntry;
import net.mstjr.murmur.logging.LogListHelper;
import net.mstjr.murmur.proxy.server.*;
import net.mstjr.murmur.proxy.server.channel.ACL;
import net.mstjr.murmur.proxy.server.channel.Channel;
import net.mstjr.murmur.proxy.server.entities.Ban;
import net.mstjr.murmur.proxy.server.entities.Group;
import net.mstjr.murmur.proxy.server.entities.Tree;
import net.mstjr.murmur.proxy.server.users.User;
import net.mstjr.murmur.proxy.server.users.UserInfo;
import net.mstjr.murmur.prxl._ServerPrxI;
import net.mstjr.murmur.proxy.*;

/**
 * Per-server interface. This includes all methods for configuring and altering
 * the state of a single virtual server. You can retrieve a pointer to this interface
 * from one of the methods in {@link Meta}.
 **/
public interface ServerPrx extends com.zeroc.Ice.ObjectPrx {
    /**
     * Shows if the server currently running (accepting users).
     *
     * @return Run-state of server.
     **/
    default boolean isRunning()
            throws InvalidSecretException {
        return isRunning(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Shows if the server currently running (accepting users).
     *
     * @param context The Context map to send with the invocation.
     * @return Run-state of server.
     **/
    default boolean isRunning(java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            return _iceI_isRunningAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Shows if the server currently running (accepting users).
     *
     * @return Run-state of server.
     **/
    default java.util.concurrent.CompletableFuture<Boolean> isRunningAsync() {
        return _iceI_isRunningAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Shows if the server currently running (accepting users).
     *
     * @param context The Context map to send with the invocation.
     * @return Run-state of server.
     **/
    default java.util.concurrent.CompletableFuture<Boolean> isRunningAsync(java.util.Map<String, String> context) {
        return _iceI_isRunningAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Boolean> _iceI_isRunningAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Boolean> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "isRunning", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_isRunning);
        f.invoke(true, context, null, null, istr -> {
            boolean ret;
            ret = istr.readBool();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_isRunning =
            {
                    InvalidSecretException.class
            };

    /**
     * Start server.
     **/
    default void start()
            throws InvalidSecretException,
            ServerBootedException,
            ServerFailureException {
        start(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Start server.
     *
     * @param context The Context map to send with the invocation.
     **/
    default void start(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException,
            ServerFailureException {
        try {
            _iceI_startAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (ServerFailureException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Start server.
     *
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> startAsync() {
        return _iceI_startAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Start server.
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> startAsync(java.util.Map<String, String> context) {
        return _iceI_startAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_startAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "start", null, sync, _iceE_start);
        f.invoke(true, context, null, null, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_start =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class,
                    ServerFailureException.class
            };

    /**
     * Stop server.
     * Note: Server will be restarted on Murmur restart unless explicitly disabled
     * with setConf("boot", false)
     **/
    default void stop()
            throws InvalidSecretException,
            ServerBootedException {
        stop(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Stop server.
     * Note: Server will be restarted on Murmur restart unless explicitly disabled
     * with setConf("boot", false)
     *
     * @param context The Context map to send with the invocation.
     **/
    default void stop(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_stopAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Stop server.
     * Note: Server will be restarted on Murmur restart unless explicitly disabled
     * with setConf("boot", false)
     *
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> stopAsync() {
        return _iceI_stopAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Stop server.
     * Note: Server will be restarted on Murmur restart unless explicitly disabled
     * with setConf("boot", false)
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> stopAsync(java.util.Map<String, String> context) {
        return _iceI_stopAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_stopAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "stop", null, sync, _iceE_stop);
        f.invoke(true, context, null, null, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_stop =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Delete server and all it's configuration.
     **/
    default void delete()
            throws InvalidSecretException,
            ServerBootedException {
        delete(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Delete server and all it's configuration.
     *
     * @param context The Context map to send with the invocation.
     **/
    default void delete(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_deleteAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Delete server and all it's configuration.
     *
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> deleteAsync() {
        return _iceI_deleteAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Delete server and all it's configuration.
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> deleteAsync(java.util.Map<String, String> context) {
        return _iceI_deleteAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_deleteAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "delete", null, sync, _iceE_delete);
        f.invoke(true, context, null, null, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_delete =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch the server id.
     *
     * @return Unique server id.
     **/
    default int id()
            throws InvalidSecretException {
        return id(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch the server id.
     *
     * @param context The Context map to send with the invocation.
     * @return Unique server id.
     **/
    default int id(java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            return _iceI_idAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch the server id.
     *
     * @return Unique server id.
     **/
    default java.util.concurrent.CompletableFuture<Integer> idAsync() {
        return _iceI_idAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch the server id.
     *
     * @param context The Context map to send with the invocation.
     * @return Unique server id.
     **/
    default java.util.concurrent.CompletableFuture<Integer> idAsync(java.util.Map<String, String> context) {
        return _iceI_idAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_idAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "id", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_id);
        f.invoke(true, context, null, null, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_id =
            {
                    InvalidSecretException.class
            };

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     *
     * @param cb Callback interface which will receive notifications.
     * @see removeCallback
     **/
    default void addCallback(ServerCallbackPrx cb)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        addCallback(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     *
     * @param cb      Callback interface which will receive notifications.
     * @param context The Context map to send with the invocation.
     * @see removeCallback
     **/
    default void addCallback(ServerCallbackPrx cb, java.util.Map<String, String> context)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_addCallbackAsync(cb, context, true).waitForResponseOrUserEx();
        } catch (InvalidCallbackException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     *
     * @param cb Callback interface which will receive notifications.
     * @return A future that will be completed when the invocation completes.
     * @see removeCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> addCallbackAsync(ServerCallbackPrx cb) {
        return _iceI_addCallbackAsync(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Add a callback. The callback will receive notifications about changes to users and channels.
     *
     * @param cb      Callback interface which will receive notifications.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see #removeCallback(ServerCallbackPrx)
     **/
    default java.util.concurrent.CompletableFuture<Void> addCallbackAsync(ServerCallbackPrx cb, java.util.Map<String, String> context) {
        return _iceI_addCallbackAsync(cb, context, false);
    }

    /**
     * @param iceP_cb -
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_addCallbackAsync(ServerCallbackPrx iceP_cb, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "addCallback", null, sync, _iceE_addCallback);
        f.invoke(true, context, null, ostr -> {
            ostr.writeProxy(iceP_cb);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_addCallback =
            {
                    InvalidCallbackException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Remove a callback.
     *
     * @param cb Callback interface to be removed.
     **/
    default void removeCallback(ServerCallbackPrx cb)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        removeCallback(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Remove a callback.
     *
     * @param cb      Callback interface to be removed.
     * @param context The Context map to send with the invocation.
     **/
    default void removeCallback(ServerCallbackPrx cb, java.util.Map<String, String> context)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_removeCallbackAsync(cb, context, true).waitForResponseOrUserEx();
        } catch (InvalidCallbackException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Remove a callback.
     *
     * @param cb Callback interface to be removed.
     * @return A future that will be completed when the invocation completes.
     * @see addCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> removeCallbackAsync(ServerCallbackPrx cb) {
        return _iceI_removeCallbackAsync(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Remove a callback.
     *
     * @param cb      Callback interface to be removed.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see addCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> removeCallbackAsync(ServerCallbackPrx cb, java.util.Map<String, String> context) {
        return _iceI_removeCallbackAsync(cb, context, false);
    }

    /**
     * @param iceP_cb -
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_removeCallbackAsync(ServerCallbackPrx iceP_cb, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "removeCallback", null, sync, _iceE_removeCallback);
        f.invoke(true, context, null, ostr -> {
            ostr.writeProxy(iceP_cb);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_removeCallback =
            {
                    InvalidCallbackException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     *
     * @param auth Authenticator object to perform subsequent authentications.
     **/
    default void setAuthenticator(ServerAuthenticatorPrx auth)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        setAuthenticator(auth, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     *
     * @param auth    Authenticator object to perform subsequent authentications.
     * @param context The Context map to send with the invocation.
     **/
    default void setAuthenticator(ServerAuthenticatorPrx auth, java.util.Map<String, String> context)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_setAuthenticatorAsync(auth, context, true).waitForResponseOrUserEx();
        } catch (InvalidCallbackException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     *
     * @param auth Authenticator object to perform subsequent authentications.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setAuthenticatorAsync(ServerAuthenticatorPrx auth) {
        return _iceI_setAuthenticatorAsync(auth, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set external authenticator. If set, all authentications from clients are forwarded to this
     * proxy.
     *
     * @param auth    Authenticator object to perform subsequent authentications.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setAuthenticatorAsync(ServerAuthenticatorPrx auth, java.util.Map<String, String> context) {
        return _iceI_setAuthenticatorAsync(auth, context, false);
    }

    /**
     * @param iceP_auth -
     * @param context   -
     * @param sync      -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setAuthenticatorAsync(ServerAuthenticatorPrx iceP_auth, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setAuthenticator", null, sync, _iceE_setAuthenticator);
        f.invoke(true, context, null, ostr -> {
            ostr.writeProxy(iceP_auth);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setAuthenticator =
            {
                    InvalidCallbackException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Retrieve configuration item.
     *
     * @param key Configuration key.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    default String getConf(String key)
            throws InvalidSecretException,
            WriteOnlyException {
        return getConf(key, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Retrieve configuration item.
     *
     * @param key     Configuration key.
     * @param context The Context map to send with the invocation.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    default String getConf(String key, java.util.Map<String, String> context)
            throws InvalidSecretException,
            WriteOnlyException {
        try {
            return _iceI_getConfAsync(key, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (WriteOnlyException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Retrieve configuration item.
     *
     * @param key Configuration key.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    default java.util.concurrent.CompletableFuture<String> getConfAsync(String key) {
        return _iceI_getConfAsync(key, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Retrieve configuration item.
     *
     * @param key     Configuration key.
     * @param context The Context map to send with the invocation.
     * @return Configuration value. If this is empty, see {@link Meta.getDefaultConf}
     **/
    default java.util.concurrent.CompletableFuture<String> getConfAsync(String key, java.util.Map<String, String> context) {
        return _iceI_getConfAsync(key, context, false);
    }

    /**
     * @param iceP_key -
     * @param context  -
     * @param sync     -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<String> _iceI_getConfAsync(String iceP_key, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<String> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getConf", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getConf);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_key);
        }, istr -> {
            String ret;
            ret = istr.readString();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getConf =
            {
                    InvalidSecretException.class,
                    WriteOnlyException.class
            };

    /**
     * Retrieve all configuration items.
     *
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    default java.util.Map<String, String> getAllConf()
            throws InvalidSecretException {
        return getAllConf(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Retrieve all configuration items.
     *
     * @param context The Context map to send with the invocation.
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    default java.util.Map<String, String> getAllConf(java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            return _iceI_getAllConfAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Retrieve all configuration items.
     *
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<String, String>> getAllConfAsync() {
        return _iceI_getAllConfAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Retrieve all configuration items.
     *
     * @param context The Context map to send with the invocation.
     * @return All configured values. If a value isn't set here, the value from {@link Meta.getDefaultConf} is used.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<String, String>> getAllConfAsync(java.util.Map<String, String> context) {
        return _iceI_getAllConfAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<String, String>> _iceI_getAllConfAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<String, String>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getAllConf", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getAllConf);
        f.invoke(true, context, null, null, istr -> {
            java.util.Map<String, String> ret;
            ret = ConfigMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getAllConf =
            {
                    InvalidSecretException.class
            };

    /**
     * Set a configuration item.
     *
     * @param key   Configuration key.
     * @param value Configuration value.
     **/
    default void setConf(String key, String value)
            throws InvalidSecretException {
        setConf(key, value, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set a configuration item.
     *
     * @param key     Configuration key.
     * @param value   Configuration value.
     * @param context The Context map to send with the invocation.
     **/
    default void setConf(String key, String value, java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            _iceI_setConfAsync(key, value, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set a configuration item.
     *
     * @param key   Configuration key.
     * @param value Configuration value.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setConfAsync(String key, String value) {
        return _iceI_setConfAsync(key, value, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set a configuration item.
     *
     * @param key     Configuration key.
     * @param value   Configuration value.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setConfAsync(String key, String value, java.util.Map<String, String> context) {
        return _iceI_setConfAsync(key, value, context, false);
    }

    /**
     * @param iceP_key   -
     * @param iceP_value -
     * @param context    -
     * @param sync       -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setConfAsync(String iceP_key, String iceP_value, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setConf", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setConf);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_key);
            ostr.writeString(iceP_value);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setConf =
            {
                    InvalidSecretException.class
            };

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     *
     * @param pw Password.
     **/
    default void setSuperuserPassword(String pw)
            throws InvalidSecretException {
        setSuperuserPassword(pw, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     *
     * @param pw      Password.
     * @param context The Context map to send with the invocation.
     **/
    default void setSuperuserPassword(String pw, java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            _iceI_setSuperuserPasswordAsync(pw, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     *
     * @param pw Password.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setSuperuserPasswordAsync(String pw) {
        return _iceI_setSuperuserPasswordAsync(pw, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
     *
     * @param pw      Password.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setSuperuserPasswordAsync(String pw, java.util.Map<String, String> context) {
        return _iceI_setSuperuserPasswordAsync(pw, context, false);
    }

    /**
     * @param iceP_pw -
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setSuperuserPasswordAsync(String iceP_pw, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setSuperuserPassword", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setSuperuserPassword);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_pw);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setSuperuserPassword =
            {
                    InvalidSecretException.class
            };

    /**
     * Fetch log entries.
     *
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last  Last entry to fetch.
     * @return List of log entries.
     **/
    default LogEntry[] getLog(int first, int last)
            throws InvalidSecretException {
        return getLog(first, last, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch log entries.
     *
     * @param first   Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last    Last entry to fetch.
     * @param context The Context map to send with the invocation.
     * @return List of log entries.
     **/
    default LogEntry[] getLog(int first, int last, java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            return _iceI_getLogAsync(first, last, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch log entries.
     *
     * @param first Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last  Last entry to fetch.
     * @return List of log entries.
     **/
    default java.util.concurrent.CompletableFuture<LogEntry[]> getLogAsync(int first, int last) {
        return _iceI_getLogAsync(first, last, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch log entries.
     *
     * @param first   Lowest numbered entry to fetch. 0 is the most recent item.
     * @param last    Last entry to fetch.
     * @param context The Context map to send with the invocation.
     * @return List of log entries.
     **/
    default java.util.concurrent.CompletableFuture<LogEntry[]> getLogAsync(int first, int last, java.util.Map<String, String> context) {
        return _iceI_getLogAsync(first, last, context, false);
    }

    /**
     * @param iceP_first -
     * @param iceP_last  -
     * @param context    -
     * @param sync       -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<LogEntry[]> _iceI_getLogAsync(int iceP_first, int iceP_last, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<LogEntry[]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getLog", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getLog);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_first);
            ostr.writeInt(iceP_last);
        }, istr -> {
            LogEntry[] ret;
            ret = LogListHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getLog =
            {
                    InvalidSecretException.class
            };

    /**
     * Fetch length of log
     *
     * @return Number of entries in log
     **/
    default int getLogLen()
            throws InvalidSecretException {
        return getLogLen(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch length of log
     *
     * @param context The Context map to send with the invocation.
     * @return Number of entries in log
     **/
    default int getLogLen(java.util.Map<String, String> context)
            throws InvalidSecretException {
        try {
            return _iceI_getLogLenAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch length of log
     *
     * @return Number of entries in log
     **/
    default java.util.concurrent.CompletableFuture<Integer> getLogLenAsync() {
        return _iceI_getLogLenAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch length of log
     *
     * @param context The Context map to send with the invocation.
     * @return Number of entries in log
     **/
    default java.util.concurrent.CompletableFuture<Integer> getLogLenAsync(java.util.Map<String, String> context) {
        return _iceI_getLogLenAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_getLogLenAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getLogLen", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getLogLen);
        f.invoke(true, context, null, null, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getLogLen =
            {
                    InvalidSecretException.class
            };

    /**
     * Fetch all users. This returns all currently connected users on the server.
     *
     * @return List of connected users.
     * @see getState
     **/
    default java.util.Map<Integer, User> getUsers()
            throws InvalidSecretException,
            ServerBootedException {
        return getUsers(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     *
     * @param context The Context map to send with the invocation.
     * @return List of connected users.
     * @see getState
     **/
    default java.util.Map<Integer, User> getUsers(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getUsersAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     *
     * @return List of connected users.
     * @see getState
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, User>> getUsersAsync() {
        return _iceI_getUsersAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch all users. This returns all currently connected users on the server.
     *
     * @param context The Context map to send with the invocation.
     * @return List of connected users.
     * @see getState
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, User>> getUsersAsync(java.util.Map<String, String> context) {
        return _iceI_getUsersAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, User>> _iceI_getUsersAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, User>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getUsers", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getUsers);
        f.invoke(true, context, null, null, istr -> {
            java.util.Map<Integer, User> ret;
            ret = UserMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getUsers =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     *
     * @return List of defined channels.
     * @see getChannelState
     **/
    default java.util.Map<Integer, Channel> getChannels()
            throws InvalidSecretException,
            ServerBootedException {
        return getChannels(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     *
     * @param context The Context map to send with the invocation.
     * @return List of defined channels.
     * @see getChannelState
     **/
    default java.util.Map<Integer, Channel> getChannels(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getChannelsAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     *
     * @return List of defined channels.
     * @see getChannelState
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, Channel>> getChannelsAsync() {
        return _iceI_getChannelsAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
     *
     * @param context The Context map to send with the invocation.
     * @return List of defined channels.
     * @see getChannelState
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, Channel>> getChannelsAsync(java.util.Map<String, String> context) {
        return _iceI_getChannelsAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, Channel>> _iceI_getChannelsAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, Channel>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getChannels", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getChannels);
        f.invoke(true, context, null, null, istr -> {
            java.util.Map<Integer, Channel> ret;
            ret = ChannelMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getChannels =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @return Certificate list of user.
     **/
    default byte[][] getCertificateList(int session)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        return getCertificateList(session, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param context The Context map to send with the invocation.
     * @return Certificate list of user.
     **/
    default byte[][] getCertificateList(int session, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            return _iceI_getCertificateListAsync(session, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @return Certificate list of user.
     **/
    default java.util.concurrent.CompletableFuture<byte[][]> getCertificateListAsync(int session) {
        return _iceI_getCertificateListAsync(session, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch certificate of user. This returns the complete certificate chain of a user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param context The Context map to send with the invocation.
     * @return Certificate list of user.
     **/
    default java.util.concurrent.CompletableFuture<byte[][]> getCertificateListAsync(int session, java.util.Map<String, String> context) {
        return _iceI_getCertificateListAsync(session, context, false);
    }

    /**
     * @param iceP_session -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<byte[][]> _iceI_getCertificateListAsync(int iceP_session, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<byte[][]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getCertificateList", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getCertificateList);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
        }, istr -> {
            byte[][] ret;
            ret = CertificateListHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getCertificateList =
            {
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     *
     * @return Recursive tree of all channels and connected users.
     **/
    default Tree getTree()
            throws InvalidSecretException,
            ServerBootedException {
        return getTree(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     *
     * @param context The Context map to send with the invocation.
     * @return Recursive tree of all channels and connected users.
     **/
    default Tree getTree(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getTreeAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     *
     * @return Recursive tree of all channels and connected users.
     **/
    default java.util.concurrent.CompletableFuture<Tree> getTreeAsync() {
        return _iceI_getTreeAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
     * as a tree. This is primarily used for viewing the state of the server on a webpage.
     *
     * @param context The Context map to send with the invocation.
     * @return Recursive tree of all channels and connected users.
     **/
    default java.util.concurrent.CompletableFuture<Tree> getTreeAsync(java.util.Map<String, String> context) {
        return _iceI_getTreeAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Tree> _iceI_getTreeAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Tree> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getTree", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getTree);
        f.invoke(true, context, null, null, istr -> {
            final com.zeroc.IceInternal.Holder<Tree> ret = new com.zeroc.IceInternal.Holder<>();
            istr.readValue(v -> ret.value = v, Tree.class);
            istr.readPendingValues();
            return ret.value;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getTree =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch all current IP bans on the server.
     *
     * @return List of bans.
     **/
    default Ban[] getBans()
            throws InvalidSecretException,
            ServerBootedException {
        return getBans(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch all current IP bans on the server.
     *
     * @param context The Context map to send with the invocation.
     * @return List of bans.
     **/
    default Ban[] getBans(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getBansAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch all current IP bans on the server.
     *
     * @return List of bans.
     **/
    default java.util.concurrent.CompletableFuture<Ban[]> getBansAsync() {
        return _iceI_getBansAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch all current IP bans on the server.
     *
     * @param context The Context map to send with the invocation.
     * @return List of bans.
     **/
    default java.util.concurrent.CompletableFuture<Ban[]> getBansAsync(java.util.Map<String, String> context) {
        return _iceI_getBansAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Ban[]> _iceI_getBansAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Ban[]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getBans", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getBans);
        f.invoke(true, context, null, null, istr -> {
            Ban[] ret;
            ret = BanListHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getBans =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     *
     * @param bans List of bans.
     **/
    default void setBans(Ban[] bans)
            throws InvalidSecretException,
            ServerBootedException {
        setBans(bans, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     *
     * @param bans    List of bans.
     * @param context The Context map to send with the invocation.
     **/
    default void setBans(Ban[] bans, java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_setBansAsync(bans, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     *
     * @param bans List of bans.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setBansAsync(Ban[] bans) {
        return _iceI_setBansAsync(bans, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
     * append to the returned list before calling this method.
     *
     * @param bans    List of bans.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setBansAsync(Ban[] bans, java.util.Map<String, String> context) {
        return _iceI_setBansAsync(bans, context, false);
    }

    /**
     * @param iceP_bans -
     * @param context   -
     * @param sync      -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setBansAsync(Ban[] iceP_bans, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setBans", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setBans);
        f.invoke(true, context, null, ostr -> {
            BanListHelper.write(ostr, iceP_bans);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setBans =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason  Text message to show when user is kicked.
     **/
    default void kickUser(int session, String reason)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        kickUser(session, reason, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason  Text message to show when user is kicked.
     * @param context The Context map to send with the invocation.
     **/
    default void kickUser(int session, String reason, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_kickUserAsync(session, reason, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason  Text message to show when user is kicked.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> kickUserAsync(int session, String reason) {
        return _iceI_kickUserAsync(session, reason, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Kick a user. The user is not banned, and is free to rejoin the server.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param reason  Text message to show when user is kicked.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> kickUserAsync(int session, String reason, java.util.Map<String, String> context) {
        return _iceI_kickUserAsync(session, reason, context, false);
    }

    /**
     * @param iceP_session -
     * @param iceP_reason  -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_kickUserAsync(int iceP_session, String iceP_reason, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "kickUser", null, sync, _iceE_kickUser);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_reason);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_kickUser =
            {
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Get state of a single connected user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    default User getState(int session)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        return getState(session, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Get state of a single connected user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param context The Context map to send with the invocation.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    default User getState(int session, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            return _iceI_getStateAsync(session, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Get state of a single connected user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    default java.util.concurrent.CompletableFuture<User> getStateAsync(int session) {
        return _iceI_getStateAsync(session, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Get state of a single connected user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param context The Context map to send with the invocation.
     * @return State of connected user.
     * @see setState
     * @see getUsers
     **/
    default java.util.concurrent.CompletableFuture<User> getStateAsync(int session, java.util.Map<String, String> context) {
        return _iceI_getStateAsync(session, context, false);
    }

    /**
     * @param iceP_session -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<User> _iceI_getStateAsync(int iceP_session, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<User> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getState", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getState);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
        }, istr -> {
            User ret;
            ret = User.ice_read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getState =
            {
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Set user state. You can use this to move, mute and deafen users.
     *
     * @param state User state to set.
     * @see getState
     **/
    default void setState(User state)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        setState(state, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     *
     * @param state   User state to set.
     * @param context The Context map to send with the invocation.
     * @see getState
     **/
    default void setState(User state, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_setStateAsync(state, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     *
     * @param state User state to set.
     * @return A future that will be completed when the invocation completes.
     * @see getState
     **/
    default java.util.concurrent.CompletableFuture<Void> setStateAsync(User state) {
        return _iceI_setStateAsync(state, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set user state. You can use this to move, mute and deafen users.
     *
     * @param state   User state to set.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see getState
     **/
    default java.util.concurrent.CompletableFuture<Void> setStateAsync(User state, java.util.Map<String, String> context) {
        return _iceI_setStateAsync(state, context, false);
    }

    /**
     * @param iceP_state -
     * @param context    -
     * @param sync       -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setStateAsync(User iceP_state, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setState", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setState);
        f.invoke(true, context, null, ostr -> {
            User.ice_write(ostr, iceP_state);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setState =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Send text message to a single user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param text    Message to send.
     * @see sendMessageChannel
     **/
    default void sendMessage(int session, String text)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        sendMessage(session, text, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Send text message to a single user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param text    Message to send.
     * @param context The Context map to send with the invocation.
     * @see sendMessageChannel
     **/
    default void sendMessage(int session, String text, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_sendMessageAsync(session, text, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Send text message to a single user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param text    Message to send.
     * @return A future that will be completed when the invocation completes.
     * @see sendMessageChannel
     **/
    default java.util.concurrent.CompletableFuture<Void> sendMessageAsync(int session, String text) {
        return _iceI_sendMessageAsync(session, text, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Send text message to a single user.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param text    Message to send.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see sendMessageChannel
     **/
    default java.util.concurrent.CompletableFuture<Void> sendMessageAsync(int session, String text, java.util.Map<String, String> context) {
        return _iceI_sendMessageAsync(session, text, context, false);
    }

    /**
     * @param iceP_session -
     * @param iceP_text    -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_sendMessageAsync(int iceP_session, String iceP_text, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "sendMessage", null, sync, _iceE_sendMessage);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_text);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_sendMessage =
            {
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Check if user is permitted to perform action.
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm      Permission bits to check.
     * @return true if any of the permissions in perm were set for the user.
     **/
    default boolean hasPermission(int session, int channelid, int perm)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        return hasPermission(session, channelid, perm, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Check if user is permitted to perform action.
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm      Permission bits to check.
     * @param context   The Context map to send with the invocation.
     * @return true if any of the permissions in perm were set for the user.
     **/
    default boolean hasPermission(int session, int channelid, int perm, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            return _iceI_hasPermissionAsync(session, channelid, perm, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Check if user is permitted to perform action.
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm      Permission bits to check.
     * @return true if any of the permissions in perm were set for the user.
     **/
    default java.util.concurrent.CompletableFuture<Boolean> hasPermissionAsync(int session, int channelid, int perm) {
        return _iceI_hasPermissionAsync(session, channelid, perm, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Check if user is permitted to perform action.
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param perm      Permission bits to check.
     * @param context   The Context map to send with the invocation.
     * @return true if any of the permissions in perm were set for the user.
     **/
    default java.util.concurrent.CompletableFuture<Boolean> hasPermissionAsync(int session, int channelid, int perm, java.util.Map<String, String> context) {
        return _iceI_hasPermissionAsync(session, channelid, perm, context, false);
    }

    /**
     * @param iceP_session   -
     * @param iceP_channelid -
     * @param iceP_perm      -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Boolean> _iceI_hasPermissionAsync(int iceP_session, int iceP_channelid, int iceP_perm, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Boolean> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "hasPermission", null, sync, _iceE_hasPermission);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeInt(iceP_channelid);
            ostr.writeInt(iceP_perm);
        }, istr -> {
            boolean ret;
            ret = istr.readBool();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_hasPermission =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Return users effective permissions
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return bitfield of allowed actions
     **/
    default int effectivePermissions(int session, int channelid)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        return effectivePermissions(session, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Return users effective permissions
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return bitfield of allowed actions
     **/
    default int effectivePermissions(int session, int channelid, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            return _iceI_effectivePermissionsAsync(session, channelid, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Return users effective permissions
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return bitfield of allowed actions
     **/
    default java.util.concurrent.CompletableFuture<Integer> effectivePermissionsAsync(int session, int channelid) {
        return _iceI_effectivePermissionsAsync(session, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Return users effective permissions
     *
     * @param session   Connection ID of user. See {@link User.session}.
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return bitfield of allowed actions
     **/
    default java.util.concurrent.CompletableFuture<Integer> effectivePermissionsAsync(int session, int channelid, java.util.Map<String, String> context) {
        return _iceI_effectivePermissionsAsync(session, channelid, context, false);
    }

    /**
     * @param iceP_session   -
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_effectivePermissionsAsync(int iceP_session, int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "effectivePermissions", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_effectivePermissions);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeInt(iceP_channelid);
        }, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_effectivePermissions =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     *
     * @param session Session of user which should receive context entry.
     * @param action  Action string, a unique name to associate with the action.
     * @param text    Name of action shown to user.
     * @param cb      Callback interface which will receive notifications.
     * @param ctx     Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @see removeContextCallback
     **/
    default void addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        addContextCallback(session, action, text, cb, ctx, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     *
     * @param session Session of user which should receive context entry.
     * @param action  Action string, a unique name to associate with the action.
     * @param text    Name of action shown to user.
     * @param cb      Callback interface which will receive notifications.
     * @param ctx     Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @param context The Context map to send with the invocation.
     * @see removeContextCallback
     **/
    default void addContextCallback(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> context)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_addContextCallbackAsync(session, action, text, cb, ctx, context, true).waitForResponseOrUserEx();
        } catch (InvalidCallbackException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     *
     * @param session Session of user which should receive context entry.
     * @param action  Action string, a unique name to associate with the action.
     * @param text    Name of action shown to user.
     * @param cb      Callback interface which will receive notifications.
     * @param ctx     Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @return A future that will be completed when the invocation completes.
     * @see removeContextCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> addContextCallbackAsync(int session, String action, String text, ServerContextCallbackPrx cb, int ctx) {
        return _iceI_addContextCallbackAsync(session, action, text, cb, ctx, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Add a context callback. This is done per user, and will add a context menu action for the user.
     *
     * @param session Session of user which should receive context entry.
     * @param action  Action string, a unique name to associate with the action.
     * @param text    Name of action shown to user.
     * @param cb      Callback interface which will receive notifications.
     * @param ctx     Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see removeContextCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> addContextCallbackAsync(int session, String action, String text, ServerContextCallbackPrx cb, int ctx, java.util.Map<String, String> context) {
        return _iceI_addContextCallbackAsync(session, action, text, cb, ctx, context, false);
    }

    /**
     * @param iceP_session -
     * @param iceP_action  -
     * @param iceP_text    -
     * @param iceP_cb      -
     * @param iceP_ctx     -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_addContextCallbackAsync(int iceP_session, String iceP_action, String iceP_text, ServerContextCallbackPrx iceP_cb, int iceP_ctx, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "addContextCallback", null, sync, _iceE_addContextCallback);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_action);
            ostr.writeString(iceP_text);
            ostr.writeProxy(iceP_cb);
            ostr.writeInt(iceP_ctx);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_addContextCallback =
            {
                    InvalidCallbackException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Remove a callback.
     *
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @see addContextCallback
     **/
    default void removeContextCallback(ServerContextCallbackPrx cb)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        removeContextCallback(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Remove a callback.
     *
     * @param cb      Callback interface to be removed. This callback will be removed from all from all users.
     * @param context The Context map to send with the invocation.
     * @see addContextCallback
     **/
    default void removeContextCallback(ServerContextCallbackPrx cb, java.util.Map<String, String> context)
            throws InvalidCallbackException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_removeContextCallbackAsync(cb, context, true).waitForResponseOrUserEx();
        } catch (InvalidCallbackException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Remove a callback.
     *
     * @param cb Callback interface to be removed. This callback will be removed from all from all users.
     * @return A future that will be completed when the invocation completes.
     * @see addContextCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> removeContextCallbackAsync(ServerContextCallbackPrx cb) {
        return _iceI_removeContextCallbackAsync(cb, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Remove a callback.
     *
     * @param cb      Callback interface to be removed. This callback will be removed from all from all users.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see addContextCallback
     **/
    default java.util.concurrent.CompletableFuture<Void> removeContextCallbackAsync(ServerContextCallbackPrx cb, java.util.Map<String, String> context) {
        return _iceI_removeContextCallbackAsync(cb, context, false);
    }

    /**
     * @param iceP_cb -
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_removeContextCallbackAsync(ServerContextCallbackPrx iceP_cb, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "removeContextCallback", null, sync, _iceE_removeContextCallback);
        f.invoke(true, context, null, ostr -> {
            ostr.writeProxy(iceP_cb);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_removeContextCallback =
            {
                    InvalidCallbackException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Get state of single channel.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    default Channel getChannelState(int channelid)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        return getChannelState(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Get state of single channel.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    default Channel getChannelState(int channelid, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getChannelStateAsync(channelid, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Get state of single channel.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    default java.util.concurrent.CompletableFuture<Channel> getChannelStateAsync(int channelid) {
        return _iceI_getChannelStateAsync(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Get state of single channel.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return State of channel.
     * @see setChannelState
     * @see getChannels
     **/
    default java.util.concurrent.CompletableFuture<Channel> getChannelStateAsync(int channelid, java.util.Map<String, String> context) {
        return _iceI_getChannelStateAsync(channelid, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Channel> _iceI_getChannelStateAsync(int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Channel> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getChannelState", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getChannelState);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
        }, istr -> {
            Channel ret;
            ret = Channel.ice_read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getChannelState =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     *
     * @param state Channel state to set.
     * @see getChannelState
     **/
    default void setChannelState(Channel state)
            throws InvalidChannelException,
            InvalidSecretException,
            NestingLimitException,
            ServerBootedException {
        setChannelState(state, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     *
     * @param state   Channel state to set.
     * @param context The Context map to send with the invocation.
     * @see getChannelState
     **/
    default void setChannelState(Channel state, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            NestingLimitException,
            ServerBootedException {
        try {
            _iceI_setChannelStateAsync(state, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (NestingLimitException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     *
     * @param state Channel state to set.
     * @return A future that will be completed when the invocation completes.
     * @see getChannelState
     **/
    default java.util.concurrent.CompletableFuture<Void> setChannelStateAsync(Channel state) {
        return _iceI_setChannelStateAsync(state, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set state of a single channel. You can use this to move or relink channels.
     *
     * @param state   Channel state to set.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see getChannelState
     **/
    default java.util.concurrent.CompletableFuture<Void> setChannelStateAsync(Channel state, java.util.Map<String, String> context) {
        return _iceI_setChannelStateAsync(state, context, false);
    }

    /**
     * @param iceP_state -
     * @param context    -
     * @param sync       -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setChannelStateAsync(Channel iceP_state, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setChannelState", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setChannelState);
        f.invoke(true, context, null, ostr -> {
            Channel.ice_write(ostr, iceP_state);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setChannelState =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    NestingLimitException.class,
                    ServerBootedException.class
            };

    /**
     * Remove a channel and all its subchannels.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     **/
    default void removeChannel(int channelid)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        removeChannel(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Remove a channel and all its subchannels.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     **/
    default void removeChannel(int channelid, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_removeChannelAsync(channelid, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Remove a channel and all its subchannels.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> removeChannelAsync(int channelid) {
        return _iceI_removeChannelAsync(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Remove a channel and all its subchannels.
     *
     * @param channelid ID of Channel. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> removeChannelAsync(int channelid, java.util.Map<String, String> context) {
        return _iceI_removeChannelAsync(channelid, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_removeChannelAsync(int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "removeChannel", null, sync, _iceE_removeChannel);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_removeChannel =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Add a new channel.
     *
     * @param name   Name of new channel.
     * @param parent Channel ID of parent channel. See {@link Channel.id}.
     * @return ID of newly created channel.
     **/
    default int addChannel(String name, int parent)
            throws InvalidChannelException,
            InvalidSecretException,
            NestingLimitException,
            ServerBootedException {
        return addChannel(name, parent, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Add a new channel.
     *
     * @param name    Name of new channel.
     * @param parent  Channel ID of parent channel. See {@link Channel.id}.
     * @param context The Context map to send with the invocation.
     * @return ID of newly created channel.
     **/
    default int addChannel(String name, int parent, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            NestingLimitException,
            ServerBootedException {
        try {
            return _iceI_addChannelAsync(name, parent, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (NestingLimitException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Add a new channel.
     *
     * @param name   Name of new channel.
     * @param parent Channel ID of parent channel. See {@link Channel.id}.
     * @return ID of newly created channel.
     **/
    default java.util.concurrent.CompletableFuture<Integer> addChannelAsync(String name, int parent) {
        return _iceI_addChannelAsync(name, parent, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Add a new channel.
     *
     * @param name    Name of new channel.
     * @param parent  Channel ID of parent channel. See {@link Channel.id}.
     * @param context The Context map to send with the invocation.
     * @return ID of newly created channel.
     **/
    default java.util.concurrent.CompletableFuture<Integer> addChannelAsync(String name, int parent, java.util.Map<String, String> context) {
        return _iceI_addChannelAsync(name, parent, context, false);
    }

    /**
     * @param iceP_name   -
     * @param iceP_parent -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_addChannelAsync(String iceP_name, int iceP_parent, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "addChannel", null, sync, _iceE_addChannel);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_name);
            ostr.writeInt(iceP_parent);
        }, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_addChannel =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    NestingLimitException.class,
                    ServerBootedException.class
            };

    /**
     * Send text message to channel or a tree of channels.
     *
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree      If true, the message will be sent to the channel and all its subchannels.
     * @param text      Message to send.
     * @see sendMessage
     **/
    default void sendMessageChannel(int channelid, boolean tree, String text)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        sendMessageChannel(channelid, tree, text, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Send text message to channel or a tree of channels.
     *
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree      If true, the message will be sent to the channel and all its subchannels.
     * @param text      Message to send.
     * @param context   The Context map to send with the invocation.
     * @see sendMessage
     **/
    default void sendMessageChannel(int channelid, boolean tree, String text, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_sendMessageChannelAsync(channelid, tree, text, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Send text message to channel or a tree of channels.
     *
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree      If true, the message will be sent to the channel and all its subchannels.
     * @param text      Message to send.
     * @return A future that will be completed when the invocation completes.
     * @see sendMessage
     **/
    default java.util.concurrent.CompletableFuture<Void> sendMessageChannelAsync(int channelid, boolean tree, String text) {
        return _iceI_sendMessageChannelAsync(channelid, tree, text, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Send text message to channel or a tree of channels.
     *
     * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
     * @param tree      If true, the message will be sent to the channel and all its subchannels.
     * @param text      Message to send.
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     * @see sendMessage
     **/
    default java.util.concurrent.CompletableFuture<Void> sendMessageChannelAsync(int channelid, boolean tree, String text, java.util.Map<String, String> context) {
        return _iceI_sendMessageChannelAsync(channelid, tree, text, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param iceP_tree      -
     * @param iceP_text      -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_sendMessageChannelAsync(int iceP_channelid, boolean iceP_tree, String iceP_text, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "sendMessageChannel", null, sync, _iceE_sendMessageChannel);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
            ostr.writeBool(iceP_tree);
            ostr.writeString(iceP_text);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_sendMessageChannel =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Retrieve ACLs and Groups on a channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @return An instance of Server.GetACLResult.
     **/
    default Server.GetACLResult getACL(int channelid)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        return getACL(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return An instance of Server.GetACLResult.
     **/
    default Server.GetACLResult getACL(int channelid, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getACLAsync(channelid, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @return A future that will be completed with an instance of Server.GetACLResult.
     **/
    default java.util.concurrent.CompletableFuture<Server.GetACLResult> getACLAsync(int channelid) {
        return _iceI_getACLAsync(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Retrieve ACLs and Groups on a channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed with an instance of Server.GetACLResult.
     **/
    default java.util.concurrent.CompletableFuture<Server.GetACLResult> getACLAsync(int channelid, java.util.Map<String, String> context) {
        return _iceI_getACLAsync(channelid, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Server.GetACLResult> _iceI_getACLAsync(int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Server.GetACLResult> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getACL", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getACL);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
        }, istr -> {
            Server.GetACLResult ret = new Server.GetACLResult();
            ret.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getACL =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls      List of ACLs on the channel.
     * @param groups    List of groups on the channel.
     * @param inherit   Should this channel inherit ACLs from the parent channel?
     **/
    default void setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        setACL(channelid, acls, groups, inherit, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls      List of ACLs on the channel.
     * @param groups    List of groups on the channel.
     * @param inherit   Should this channel inherit ACLs from the parent channel?
     * @param context   The Context map to send with the invocation.
     **/
    default void setACL(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_setACLAsync(channelid, acls, groups, inherit, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls      List of ACLs on the channel.
     * @param groups    List of groups on the channel.
     * @param inherit   Should this channel inherit ACLs from the parent channel?
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setACLAsync(int channelid, ACL[] acls, Group[] groups, boolean inherit) {
        return _iceI_setACLAsync(channelid, acls, groups, inherit, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
     *
     * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
     * @param acls      List of ACLs on the channel.
     * @param groups    List of groups on the channel.
     * @param inherit   Should this channel inherit ACLs from the parent channel?
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setACLAsync(int channelid, ACL[] acls, Group[] groups, boolean inherit, java.util.Map<String, String> context) {
        return _iceI_setACLAsync(channelid, acls, groups, inherit, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param iceP_acls      -
     * @param iceP_groups    -
     * @param iceP_inherit   -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setACLAsync(int iceP_channelid, ACL[] iceP_acls, Group[] iceP_groups, boolean iceP_inherit, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setACL", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setACL);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
            ACLListHelper.write(ostr, iceP_acls);
            GroupListHelper.write(ostr, iceP_groups);
            ostr.writeBool(iceP_inherit);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setACL =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to add to.
     **/
    default void addUserToGroup(int channelid, int session, String group)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        addUserToGroup(channelid, session, group, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to add to.
     * @param context   The Context map to send with the invocation.
     **/
    default void addUserToGroup(int channelid, int session, String group, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_addUserToGroupAsync(channelid, session, group, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to add to.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> addUserToGroupAsync(int channelid, int session, String group) {
        return _iceI_addUserToGroupAsync(channelid, session, group, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to add to.
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> addUserToGroupAsync(int channelid, int session, String group, java.util.Map<String, String> context) {
        return _iceI_addUserToGroupAsync(channelid, session, group, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param iceP_session   -
     * @param iceP_group     -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_addUserToGroupAsync(int iceP_channelid, int iceP_session, String iceP_group, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "addUserToGroup", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_addUserToGroup);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_group);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_addUserToGroup =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to remove from.
     **/
    default void removeUserFromGroup(int channelid, int session, String group)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        removeUserFromGroup(channelid, session, group, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to remove from.
     * @param context   The Context map to send with the invocation.
     **/
    default void removeUserFromGroup(int channelid, int session, String group, java.util.Map<String, String> context)
            throws InvalidChannelException,
            InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_removeUserFromGroupAsync(channelid, session, group, context, true).waitForResponseOrUserEx();
        } catch (InvalidChannelException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to remove from.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> removeUserFromGroupAsync(int channelid, int session, String group) {
        return _iceI_removeUserFromGroupAsync(channelid, session, group, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
     *
     * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
     * @param session   Connection ID of user. See {@link User.session}.
     * @param group     Group name to remove from.
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> removeUserFromGroupAsync(int channelid, int session, String group, java.util.Map<String, String> context) {
        return _iceI_removeUserFromGroupAsync(channelid, session, group, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param iceP_session   -
     * @param iceP_group     -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_removeUserFromGroupAsync(int iceP_channelid, int iceP_session, String iceP_group, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "removeUserFromGroup", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_removeUserFromGroup);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_group);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_removeUserFromGroup =
            {
                    InvalidChannelException.class,
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param source  Group name to redirect from.
     * @param target  Group name to redirect to.
     **/
    default void redirectWhisperGroup(int session, String source, String target)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        redirectWhisperGroup(session, source, target, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param source  Group name to redirect from.
     * @param target  Group name to redirect to.
     * @param context The Context map to send with the invocation.
     **/
    default void redirectWhisperGroup(int session, String source, String target, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidSessionException,
            ServerBootedException {
        try {
            _iceI_redirectWhisperGroupAsync(session, source, target, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidSessionException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param source  Group name to redirect from.
     * @param target  Group name to redirect to.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> redirectWhisperGroupAsync(int session, String source, String target) {
        return _iceI_redirectWhisperGroupAsync(session, source, target, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
     * To remove a redirect pass an empty target string. This is intended for context groups.
     *
     * @param session Connection ID of user. See {@link User.session}.
     * @param source  Group name to redirect from.
     * @param target  Group name to redirect to.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> redirectWhisperGroupAsync(int session, String source, String target, java.util.Map<String, String> context) {
        return _iceI_redirectWhisperGroupAsync(session, source, target, context, false);
    }

    /**
     * @param iceP_session -
     * @param iceP_source  -
     * @param iceP_target  -
     * @param context      -
     * @param sync         -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_redirectWhisperGroupAsync(int iceP_session, String iceP_source, String iceP_target, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "redirectWhisperGroup", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_redirectWhisperGroup);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_session);
            ostr.writeString(iceP_source);
            ostr.writeString(iceP_target);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_redirectWhisperGroup =
            {
                    InvalidSecretException.class,
                    InvalidSessionException.class,
                    ServerBootedException.class
            };

    /**
     * Map a list of {@link User.userid} to a matching name.
     *
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    default java.util.Map<Integer, String> getUserNames(int[] ids)
            throws InvalidSecretException,
            ServerBootedException {
        return getUserNames(ids, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     *
     * @param context The Context map to send with the invocation.
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    default java.util.Map<Integer, String> getUserNames(int[] ids, java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getUserNamesAsync(ids, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     *
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, String>> getUserNamesAsync(int[] ids) {
        return _iceI_getUserNamesAsync(ids, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Map a list of {@link User.userid} to a matching name.
     *
     * @param context The Context map to send with the invocation.
     * @return Matching list of names, with an empty string representing invalid or unknown ids.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, String>> getUserNamesAsync(int[] ids, java.util.Map<String, String> context) {
        return _iceI_getUserNamesAsync(ids, context, false);
    }

    /**
     * @param iceP_ids -
     * @param context  -
     * @param sync     -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, String>> _iceI_getUserNamesAsync(int[] iceP_ids, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, String>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getUserNames", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getUserNames);
        f.invoke(true, context, null, ostr -> {
            ostr.writeIntSeq(iceP_ids);
        }, istr -> {
            java.util.Map<Integer, String> ret;
            ret = NameMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getUserNames =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Map a list of user names to a matching id.
     *
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     **/
    default java.util.Map<String, Integer> getUserIds(String[] names)
            throws InvalidSecretException,
            ServerBootedException {
        return getUserIds(names, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Map a list of user names to a matching id.
     *
     * @param context The Context map to send with the invocation.
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     **/
    default java.util.Map<String, Integer> getUserIds(String[] names, java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getUserIdsAsync(names, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Map a list of user names to a matching id.
     *
     * @return A future that will be completed with the result.
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<String, Integer>> getUserIdsAsync(String[] names) {
        return _iceI_getUserIdsAsync(names, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Map a list of user names to a matching id.
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed with the result.
     * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<String, Integer>> getUserIdsAsync(String[] names, java.util.Map<String, String> context) {
        return _iceI_getUserIdsAsync(names, context, false);
    }

    /**
     * @param iceP_names -
     * @param context    -
     * @param sync       -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<String, Integer>> _iceI_getUserIdsAsync(String[] iceP_names, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<String, Integer>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getUserIds", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getUserIds);
        f.invoke(true, context, null, ostr -> {
            ostr.writeStringSeq(iceP_names);
        }, istr -> {
            java.util.Map<String, Integer> ret;
            ret = IdMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getUserIds =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Register a new user.
     *
     * @param info Information about new user. Must include at least "name".
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    default int registerUser(java.util.Map<UserInfo, String> info)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        return registerUser(info, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Register a new user.
     *
     * @param info    Information about new user. Must include at least "name".
     * @param context The Context map to send with the invocation.
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    default int registerUser(java.util.Map<UserInfo, String> info, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        try {
            return _iceI_registerUserAsync(info, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Register a new user.
     *
     * @param info Information about new user. Must include at least "name".
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    default java.util.concurrent.CompletableFuture<Integer> registerUserAsync(java.util.Map<UserInfo, String> info) {
        return _iceI_registerUserAsync(info, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Register a new user.
     *
     * @param info    Information about new user. Must include at least "name".
     * @param context The Context map to send with the invocation.
     * @return The ID of the user. See {@link RegisteredUser.userid}.
     **/
    default java.util.concurrent.CompletableFuture<Integer> registerUserAsync(java.util.Map<UserInfo, String> info, java.util.Map<String, String> context) {
        return _iceI_registerUserAsync(info, context, false);
    }

    /**
     * @param iceP_info -
     * @param context   -
     * @param sync      -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_registerUserAsync(java.util.Map<UserInfo, String> iceP_info, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "registerUser", null, sync, _iceE_registerUser);
        f.invoke(true, context, null, ostr -> {
            UserInfoMapHelper.write(ostr, iceP_info);
        }, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_registerUser =
            {
                    InvalidSecretException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Remove a user registration.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     **/
    default void unregisterUser(int userid)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        unregisterUser(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Remove a user registration.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     **/
    default void unregisterUser(int userid, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        try {
            _iceI_unregisterUserAsync(userid, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Remove a user registration.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> unregisterUserAsync(int userid) {
        return _iceI_unregisterUserAsync(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Remove a user registration.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> unregisterUserAsync(int userid, java.util.Map<String, String> context) {
        return _iceI_unregisterUserAsync(userid, context, false);
    }

    /**
     * @param iceP_userid -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_unregisterUserAsync(int iceP_userid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "unregisterUser", null, sync, _iceE_unregisterUser);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_unregisterUser =
            {
                    InvalidSecretException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     **/
    default void updateRegistration(int userid, java.util.Map<UserInfo, String> info)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        updateRegistration(userid, info, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     *
     * @param context The Context map to send with the invocation.
     **/
    default void updateRegistration(int userid, java.util.Map<UserInfo, String> info, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        try {
            _iceI_updateRegistrationAsync(userid, info, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     *
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> updateRegistrationAsync(int userid, java.util.Map<UserInfo, String> info) {
        return _iceI_updateRegistrationAsync(userid, info, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Update the registration for a user. You can use this to set the email or password of a user,
     * and can also use it to change the user's name.
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> updateRegistrationAsync(int userid, java.util.Map<UserInfo, String> info, java.util.Map<String, String> context) {
        return _iceI_updateRegistrationAsync(userid, info, context, false);
    }

    /**
     * @param iceP_userid -
     * @param iceP_info   -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_updateRegistrationAsync(int iceP_userid, java.util.Map<UserInfo, String> iceP_info, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "updateRegistration", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_updateRegistration);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
            UserInfoMapHelper.write(ostr, iceP_info);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_updateRegistration =
            {
                    InvalidSecretException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch registration for a single user.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Registration record.
     **/
    default java.util.Map<UserInfo, String> getRegistration(int userid)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        return getRegistration(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch registration for a single user.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     * @return Registration record.
     **/
    default java.util.Map<UserInfo, String> getRegistration(int userid, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        try {
            return _iceI_getRegistrationAsync(userid, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch registration for a single user.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Registration record.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<UserInfo, String>> getRegistrationAsync(int userid) {
        return _iceI_getRegistrationAsync(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch registration for a single user.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     * @return Registration record.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<UserInfo, String>> getRegistrationAsync(int userid, java.util.Map<String, String> context) {
        return _iceI_getRegistrationAsync(userid, context, false);
    }

    /**
     * @param iceP_userid -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<UserInfo, String>> _iceI_getRegistrationAsync(int iceP_userid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<UserInfo, String>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getRegistration", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getRegistration);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
        }, istr -> {
            java.util.Map<UserInfo, String> ret;
            ret = UserInfoMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getRegistration =
            {
                    InvalidSecretException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch a group of registered users.
     *
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @return List of registration records.
     **/
    default java.util.Map<Integer, String> getRegisteredUsers(String filter)
            throws InvalidSecretException,
            ServerBootedException {
        return getRegisteredUsers(filter, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch a group of registered users.
     *
     * @param filter  Substring of user name. If blank, will retrieve all registered users.
     * @param context The Context map to send with the invocation.
     * @return List of registration records.
     **/
    default java.util.Map<Integer, String> getRegisteredUsers(String filter, java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getRegisteredUsersAsync(filter, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch a group of registered users.
     *
     * @param filter Substring of user name. If blank, will retrieve all registered users.
     * @return List of registration records.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, String>> getRegisteredUsersAsync(String filter) {
        return _iceI_getRegisteredUsersAsync(filter, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch a group of registered users.
     *
     * @param filter  Substring of user name. If blank, will retrieve all registered users.
     * @param context The Context map to send with the invocation.
     * @return List of registration records.
     **/
    default java.util.concurrent.CompletableFuture<java.util.Map<Integer, String>> getRegisteredUsersAsync(String filter, java.util.Map<String, String> context) {
        return _iceI_getRegisteredUsersAsync(filter, context, false);
    }

    /**
     * @param iceP_filter -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, String>> _iceI_getRegisteredUsersAsync(String iceP_filter, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<java.util.Map<Integer, String>> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getRegisteredUsers", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getRegisteredUsers);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_filter);
        }, istr -> {
            java.util.Map<Integer, String> ret;
            ret = NameMapHelper.read(istr);
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getRegisteredUsers =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     *
     * @param name User name. See {@link RegisteredUser.name}.
     * @param pw   User password.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    default int verifyPassword(String name, String pw)
            throws InvalidSecretException,
            ServerBootedException {
        return verifyPassword(name, pw, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     *
     * @param name    User name. See {@link RegisteredUser.name}.
     * @param pw      User password.
     * @param context The Context map to send with the invocation.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    default int verifyPassword(String name, String pw, java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_verifyPasswordAsync(name, pw, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     *
     * @param name User name. See {@link RegisteredUser.name}.
     * @param pw   User password.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    default java.util.concurrent.CompletableFuture<Integer> verifyPasswordAsync(String name, String pw) {
        return _iceI_verifyPasswordAsync(name, pw, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Verify the password of a user. You can use this to verify a user's credentials.
     *
     * @param name    User name. See {@link RegisteredUser.name}.
     * @param pw      User password.
     * @param context The Context map to send with the invocation.
     * @return User ID of registered user (See {@link RegisteredUser.userid}), -1 for failed authentication or -2 for unknown usernames.
     **/
    default java.util.concurrent.CompletableFuture<Integer> verifyPasswordAsync(String name, String pw, java.util.Map<String, String> context) {
        return _iceI_verifyPasswordAsync(name, pw, context, false);
    }

    /**
     * @param iceP_name -
     * @param iceP_pw   -
     * @param context   -
     * @param sync      -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_verifyPasswordAsync(String iceP_name, String iceP_pw, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "verifyPassword", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_verifyPassword);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_name);
            ostr.writeString(iceP_pw);
        }, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_verifyPassword =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Custom texture associated with user or an empty texture.
     **/
    default byte[] getTexture(int userid)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        return getTexture(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     * @return Custom texture associated with user or an empty texture.
     **/
    default byte[] getTexture(int userid, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidUserException,
            ServerBootedException {
        try {
            return _iceI_getTextureAsync(userid, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @return Custom texture associated with user or an empty texture.
     **/
    default java.util.concurrent.CompletableFuture<byte[]> getTextureAsync(int userid) {
        return _iceI_getTextureAsync(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param context The Context map to send with the invocation.
     * @return Custom texture associated with user or an empty texture.
     **/
    default java.util.concurrent.CompletableFuture<byte[]> getTextureAsync(int userid, java.util.Map<String, String> context) {
        return _iceI_getTextureAsync(userid, context, false);
    }

    /**
     * @param iceP_userid -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<byte[]> _iceI_getTextureAsync(int iceP_userid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<byte[]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getTexture", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getTexture);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
        }, istr -> {
            byte[] ret;
            ret = istr.readByteSeq();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getTexture =
            {
                    InvalidSecretException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Set a user texture (now called avatar).
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex    Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     **/
    default void setTexture(int userid, byte[] tex)
            throws InvalidSecretException,
            InvalidTextureException,
            InvalidUserException,
            ServerBootedException {
        setTexture(userid, tex, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Set a user texture (now called avatar).
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex     Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     * @param context The Context map to send with the invocation.
     **/
    default void setTexture(int userid, byte[] tex, java.util.Map<String, String> context)
            throws InvalidSecretException,
            InvalidTextureException,
            InvalidUserException,
            ServerBootedException {
        try {
            _iceI_setTextureAsync(userid, tex, context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (InvalidTextureException ex) {
            throw ex;
        } catch (InvalidUserException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Set a user texture (now called avatar).
     *
     * @param userid ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex    Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setTextureAsync(int userid, byte[] tex) {
        return _iceI_setTextureAsync(userid, tex, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Set a user texture (now called avatar).
     *
     * @param userid  ID of registered user. See {@link RegisteredUser.userid}.
     * @param tex     Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> setTextureAsync(int userid, byte[] tex, java.util.Map<String, String> context) {
        return _iceI_setTextureAsync(userid, tex, context, false);
    }

    /**
     * @param iceP_userid -
     * @param iceP_tex    -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_setTextureAsync(int iceP_userid, byte[] iceP_tex, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "setTexture", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_setTexture);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
            ostr.writeByteSeq(iceP_tex);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_setTexture =
            {
                    InvalidSecretException.class,
                    InvalidTextureException.class,
                    InvalidUserException.class,
                    ServerBootedException.class
            };

    /**
     * Get virtual server uptime.
     *
     * @return Uptime of the virtual server in seconds
     **/
    default int getUptime()
            throws InvalidSecretException,
            ServerBootedException {
        return getUptime(com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Get virtual server uptime.
     *
     * @param context The Context map to send with the invocation.
     * @return Uptime of the virtual server in seconds
     **/
    default int getUptime(java.util.Map<String, String> context)
            throws InvalidSecretException,
            ServerBootedException {
        try {
            return _iceI_getUptimeAsync(context, true).waitForResponseOrUserEx();
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Get virtual server uptime.
     *
     * @return Uptime of the virtual server in seconds
     **/
    default java.util.concurrent.CompletableFuture<Integer> getUptimeAsync() {
        return _iceI_getUptimeAsync(com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Get virtual server uptime.
     *
     * @param context The Context map to send with the invocation.
     * @return Uptime of the virtual server in seconds
     **/
    default java.util.concurrent.CompletableFuture<Integer> getUptimeAsync(java.util.Map<String, String> context) {
        return _iceI_getUptimeAsync(context, false);
    }

    /**
     * @param context -
     * @param sync    -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Integer> _iceI_getUptimeAsync(java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Integer> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getUptime", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_getUptime);
        f.invoke(true, context, null, null, istr -> {
            int ret;
            ret = istr.readInt();
            return ret;
        });
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_getUptime =
            {
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Update the server's certificate information.
     * <p>
     * Reconfigure the running server's TLS socket with the given
     * certificate and private key.
     * <p>
     * The certificate and and private key must be PEM formatted.
     * <p>
     * New clients will see the new certificate.
     * Existing clients will continue to see the certificate the server
     * was using when they connected to it.
     * <p>
     * This method throws InvalidInputDataException if any of the
     * following errors happen:
     * - Unable to decode the PEM certificate and/or private key.
     * - Unable to decrypt the private key with the given passphrase.
     * - The certificate and/or private key do not contain RSA keys.
     * - The certificate is not usable with the given private key.
     **/
    default void updateCertificate(String certificate, String privateKey, String passphrase)
            throws InvalidInputDataException,
            InvalidSecretException,
            ServerBootedException {
        updateCertificate(certificate, privateKey, passphrase, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Update the server's certificate information.
     * <p>
     * Reconfigure the running server's TLS socket with the given
     * certificate and private key.
     * <p>
     * The certificate and and private key must be PEM formatted.
     * <p>
     * New clients will see the new certificate.
     * Existing clients will continue to see the certificate the server
     * was using when they connected to it.
     * <p>
     * This method throws InvalidInputDataException if any of the
     * following errors happen:
     * - Unable to decode the PEM certificate and/or private key.
     * - Unable to decrypt the private key with the given passphrase.
     * - The certificate and/or private key do not contain RSA keys.
     * - The certificate is not usable with the given private key.
     *
     * @param context The Context map to send with the invocation.
     **/
    default void updateCertificate(String certificate, String privateKey, String passphrase, java.util.Map<String, String> context)
            throws InvalidInputDataException,
            InvalidSecretException,
            ServerBootedException {
        try {
            _iceI_updateCertificateAsync(certificate, privateKey, passphrase, context, true).waitForResponseOrUserEx();
        } catch (InvalidInputDataException ex) {
            throw ex;
        } catch (InvalidSecretException ex) {
            throw ex;
        } catch (ServerBootedException ex) {
            throw ex;
        } catch (com.zeroc.Ice.UserException ex) {
            throw new com.zeroc.Ice.UnknownUserException(ex.ice_id(), ex);
        }
    }

    /**
     * Update the server's certificate information.
     * <p>
     * Reconfigure the running server's TLS socket with the given
     * certificate and private key.
     * <p>
     * The certificate and and private key must be PEM formatted.
     * <p>
     * New clients will see the new certificate.
     * Existing clients will continue to see the certificate the server
     * was using when they connected to it.
     * <p>
     * This method throws InvalidInputDataException if any of the
     * following errors happen:
     * - Unable to decode the PEM certificate and/or private key.
     * - Unable to decrypt the private key with the given passphrase.
     * - The certificate and/or private key do not contain RSA keys.
     * - The certificate is not usable with the given private key.
     *
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> updateCertificateAsync(String certificate, String privateKey, String passphrase) {
        return _iceI_updateCertificateAsync(certificate, privateKey, passphrase, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Update the server's certificate information.
     * <p>
     * Reconfigure the running server's TLS socket with the given
     * certificate and private key.
     * <p>
     * The certificate and and private key must be PEM formatted.
     * <p>
     * New clients will see the new certificate.
     * Existing clients will continue to see the certificate the server
     * was using when they connected to it.
     * <p>
     * This method throws InvalidInputDataException if any of the
     * following errors happen:
     * - Unable to decode the PEM certificate and/or private key.
     * - Unable to decrypt the private key with the given passphrase.
     * - The certificate and/or private key do not contain RSA keys.
     * - The certificate is not usable with the given private key.
     *
     * @param context The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> updateCertificateAsync(String certificate, String privateKey, String passphrase, java.util.Map<String, String> context) {
        return _iceI_updateCertificateAsync(certificate, privateKey, passphrase, context, false);
    }

    /**
     * @param iceP_certificate -
     * @param iceP_privateKey  -
     * @param iceP_passphrase  -
     * @param context          -
     * @param sync             -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_updateCertificateAsync(String iceP_certificate, String iceP_privateKey, String iceP_passphrase, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "updateCertificate", com.zeroc.Ice.OperationMode.Idempotent, sync, _iceE_updateCertificate);
        f.invoke(true, context, null, ostr -> {
            ostr.writeString(iceP_certificate);
            ostr.writeString(iceP_privateKey);
            ostr.writeString(iceP_passphrase);
        }, null);
        return f;
    }

    /**
     * @hidden
     */
    Class<?>[] _iceE_updateCertificate =
            {
                    InvalidInputDataException.class,
                    InvalidSecretException.class,
                    ServerBootedException.class
            };

    /**
     * Makes the given user start listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     **/
    default void startListening(int userid, int channelid) {
        startListening(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Makes the given user start listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     **/
    default void startListening(int userid, int channelid, java.util.Map<String, String> context) {
        _iceI_startListeningAsync(userid, channelid, context, true).waitForResponse();
    }

    /**
     * Makes the given user start listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> startListeningAsync(int userid, int channelid) {
        return _iceI_startListeningAsync(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Makes the given user start listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> startListeningAsync(int userid, int channelid, java.util.Map<String, String> context) {
        return _iceI_startListeningAsync(userid, channelid, context, false);
    }

    /**
     * @param iceP_userid    -
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_startListeningAsync(int iceP_userid, int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "startListening", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(false, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
            ostr.writeInt(iceP_channelid);
        }, null);
        return f;
    }

    /**
     * Makes the given user stop listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     **/
    default void stopListening(int userid, int channelid) {
        stopListening(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * Makes the given user stop listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     **/
    default void stopListening(int userid, int channelid, java.util.Map<String, String> context) {
        _iceI_stopListeningAsync(userid, channelid, context, true).waitForResponse();
    }

    /**
     * Makes the given user stop listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> stopListeningAsync(int userid, int channelid) {
        return _iceI_stopListeningAsync(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * Makes the given user stop listening to the given channel.
     *
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> stopListeningAsync(int userid, int channelid, java.util.Map<String, String> context) {
        return _iceI_stopListeningAsync(userid, channelid, context, false);
    }

    /**
     * @param iceP_userid    -
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_stopListeningAsync(int iceP_userid, int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "stopListening", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(false, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
            ostr.writeInt(iceP_channelid);
        }, null);
        return f;
    }

    /**
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @return s Whether the given user is currently listening to the given channel
     **/
    default boolean isListening(int userid, int channelid) {
        return isListening(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return s Whether the given user is currently listening to the given channel
     **/
    default boolean isListening(int userid, int channelid, java.util.Map<String, String> context) {
        return _iceI_isListeningAsync(userid, channelid, context, true).waitForResponse();
    }

    /**
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @return s Whether the given user is currently listening to the given channel
     **/
    default java.util.concurrent.CompletableFuture<Boolean> isListeningAsync(int userid, int channelid) {
        return _iceI_isListeningAsync(userid, channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * @param userid    The ID of the user
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return s Whether the given user is currently listening to the given channel
     **/
    default java.util.concurrent.CompletableFuture<Boolean> isListeningAsync(int userid, int channelid, java.util.Map<String, String> context) {
        return _iceI_isListeningAsync(userid, channelid, context, false);
    }

    /**
     * @param iceP_userid    -
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Boolean> _iceI_isListeningAsync(int iceP_userid, int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Boolean> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "isListening", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
            ostr.writeInt(iceP_channelid);
        }, istr -> {
            boolean ret;
            ret = istr.readBool();
            return ret;
        });
        return f;
    }

    /**
     * @param userid The ID of the user
     * @return s An ID-list of channels the given user is listening to
     **/
    default int[] getListeningChannels(int userid) {
        return getListeningChannels(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * @param userid  The ID of the user
     * @param context The Context map to send with the invocation.
     * @return s An ID-list of channels the given user is listening to
     **/
    default int[] getListeningChannels(int userid, java.util.Map<String, String> context) {
        return _iceI_getListeningChannelsAsync(userid, context, true).waitForResponse();
    }

    /**
     * @param userid The ID of the user
     * @return s An ID-list of channels the given user is listening to
     **/
    default java.util.concurrent.CompletableFuture<int[]> getListeningChannelsAsync(int userid) {
        return _iceI_getListeningChannelsAsync(userid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * @param userid  The ID of the user
     * @param context The Context map to send with the invocation.
     * @return s An ID-list of channels the given user is listening to
     **/
    default java.util.concurrent.CompletableFuture<int[]> getListeningChannelsAsync(int userid, java.util.Map<String, String> context) {
        return _iceI_getListeningChannelsAsync(userid, context, false);
    }

    /**
     * @param iceP_userid -
     * @param context     -
     * @param sync        -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<int[]> _iceI_getListeningChannelsAsync(int iceP_userid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<int[]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getListeningChannels", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_userid);
        }, istr -> {
            int[] ret;
            ret = istr.readIntSeq();
            return ret;
        });
        return f;
    }

    /**
     * @param channelid The ID of the channel
     * @return s An ID-list of users listening to the given channel
     **/
    default int[] getListeningUsers(int channelid) {
        return getListeningUsers(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return s An ID-list of users listening to the given channel
     **/
    default int[] getListeningUsers(int channelid, java.util.Map<String, String> context) {
        return _iceI_getListeningUsersAsync(channelid, context, true).waitForResponse();
    }

    /**
     * @param channelid The ID of the channel
     * @return s An ID-list of users listening to the given channel
     **/
    default java.util.concurrent.CompletableFuture<int[]> getListeningUsersAsync(int channelid) {
        return _iceI_getListeningUsersAsync(channelid, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * @param channelid The ID of the channel
     * @param context   The Context map to send with the invocation.
     * @return s An ID-list of users listening to the given channel
     **/
    default java.util.concurrent.CompletableFuture<int[]> getListeningUsersAsync(int channelid, java.util.Map<String, String> context) {
        return _iceI_getListeningUsersAsync(channelid, context, false);
    }

    /**
     * @param iceP_channelid -
     * @param context        -
     * @param sync           -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<int[]> _iceI_getListeningUsersAsync(int iceP_channelid, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<int[]> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "getListeningUsers", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(true, context, null, ostr -> {
            ostr.writeInt(iceP_channelid);
        }, istr -> {
            int[] ret;
            ret = istr.readIntSeq();
            return ret;
        });
        return f;
    }

    /**
     * @param receiverUserIDs list of IDs of the users the message shall be sent to
     **/
    default void sendWelcomeMessage(int[] receiverUserIDs) {
        sendWelcomeMessage(receiverUserIDs, com.zeroc.Ice.ObjectPrx.noExplicitContext);
    }

    /**
     * @param receiverUserIDs list of IDs of the users the message shall be sent to
     * @param context         The Context map to send with the invocation.
     **/
    default void sendWelcomeMessage(int[] receiverUserIDs, java.util.Map<String, String> context) {
        _iceI_sendWelcomeMessageAsync(receiverUserIDs, context, true).waitForResponse();
    }

    /**
     * @param receiverUserIDs list of IDs of the users the message shall be sent to
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> sendWelcomeMessageAsync(int[] receiverUserIDs) {
        return _iceI_sendWelcomeMessageAsync(receiverUserIDs, com.zeroc.Ice.ObjectPrx.noExplicitContext, false);
    }

    /**
     * @param receiverUserIDs list of IDs of the users the message shall be sent to
     * @param context         The Context map to send with the invocation.
     * @return A future that will be completed when the invocation completes.
     **/
    default java.util.concurrent.CompletableFuture<Void> sendWelcomeMessageAsync(int[] receiverUserIDs, java.util.Map<String, String> context) {
        return _iceI_sendWelcomeMessageAsync(receiverUserIDs, context, false);
    }

    /**
     * @param iceP_receiverUserIDs -
     * @param context              -
     * @param sync                 -
     * @return -
     * @hidden
     **/
    default com.zeroc.IceInternal.OutgoingAsync<Void> _iceI_sendWelcomeMessageAsync(int[] iceP_receiverUserIDs, java.util.Map<String, String> context, boolean sync) {
        com.zeroc.IceInternal.OutgoingAsync<Void> f = new com.zeroc.IceInternal.OutgoingAsync<>(this, "sendWelcomeMessage", com.zeroc.Ice.OperationMode.Idempotent, sync, null);
        f.invoke(false, context, null, ostr -> {
            ostr.writeIntSeq(iceP_receiverUserIDs);
        }, null);
        return f;
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     *
     * @param obj The untyped proxy.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ServerPrx checkedCast(com.zeroc.Ice.ObjectPrx obj) {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, ice_staticId(), ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Contacts the remote server to verify that the object implements this type.
     * Raises a local exception if a communication error occurs.
     *
     * @param obj     The untyped proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ServerPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, java.util.Map<String, String> context) {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, context, ice_staticId(), ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     *
     * @param obj   The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ServerPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet) {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, ice_staticId(), ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Contacts the remote server to verify that a facet of the object implements this type.
     * Raises a local exception if a communication error occurs.
     *
     * @param obj     The untyped proxy.
     * @param facet   The name of the desired facet.
     * @param context The Context map to send with the invocation.
     * @return A proxy for this type, or null if the object does not support this type.
     **/
    static ServerPrx checkedCast(com.zeroc.Ice.ObjectPrx obj, String facet, java.util.Map<String, String> context) {
        return com.zeroc.Ice.ObjectPrx._checkedCast(obj, facet, context, ice_staticId(), ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     *
     * @param obj The untyped proxy.
     * @return A proxy for this type.
     **/
    static ServerPrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj) {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Downcasts the given proxy to this type without contacting the remote server.
     *
     * @param obj   The untyped proxy.
     * @param facet The name of the desired facet.
     * @return A proxy for this type.
     **/
    static ServerPrx uncheckedCast(com.zeroc.Ice.ObjectPrx obj, String facet) {
        return com.zeroc.Ice.ObjectPrx._uncheckedCast(obj, facet, ServerPrx.class, _ServerPrxI.class);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the per-proxy context.
     *
     * @param newContext The context for the new proxy.
     * @return A proxy with the specified per-proxy context.
     **/
    @Override
    default ServerPrx ice_context(java.util.Map<String, String> newContext) {
        return (ServerPrx) _ice_context(newContext);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the adapter ID.
     *
     * @param newAdapterId The adapter ID for the new proxy.
     * @return A proxy with the specified adapter ID.
     **/
    @Override
    default ServerPrx ice_adapterId(String newAdapterId) {
        return (ServerPrx) _ice_adapterId(newAdapterId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoints.
     *
     * @param newEndpoints The endpoints for the new proxy.
     * @return A proxy with the specified endpoints.
     **/
    @Override
    default ServerPrx ice_endpoints(com.zeroc.Ice.Endpoint[] newEndpoints) {
        return (ServerPrx) _ice_endpoints(newEndpoints);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator cache timeout.
     *
     * @param newTimeout The new locator cache timeout (in seconds).
     * @return A proxy with the specified locator cache timeout.
     **/
    @Override
    default ServerPrx ice_locatorCacheTimeout(int newTimeout) {
        return (ServerPrx) _ice_locatorCacheTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the invocation timeout.
     *
     * @param newTimeout The new invocation timeout (in seconds).
     * @return A proxy with the specified invocation timeout.
     **/
    @Override
    default ServerPrx ice_invocationTimeout(int newTimeout) {
        return (ServerPrx) _ice_invocationTimeout(newTimeout);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for connection caching.
     *
     * @param newCache <code>true</code> if the new proxy should cache connections; <code>false</code> otherwise.
     * @return A proxy with the specified caching policy.
     **/
    @Override
    default ServerPrx ice_connectionCached(boolean newCache) {
        return (ServerPrx) _ice_connectionCached(newCache);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the endpoint selection policy.
     *
     * @param newType The new endpoint selection policy.
     * @return A proxy with the specified endpoint selection policy.
     **/
    @Override
    default ServerPrx ice_endpointSelection(com.zeroc.Ice.EndpointSelectionType newType) {
        return (ServerPrx) _ice_endpointSelection(newType);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for how it selects endpoints.
     *
     * @param b If <code>b</code> is <code>true</code>, only endpoints that use a secure transport are
     *          used by the new proxy. If <code>b</code> is false, the returned proxy uses both secure and
     *          insecure endpoints.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default ServerPrx ice_secure(boolean b) {
        return (ServerPrx) _ice_secure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the encoding used to marshal parameters.
     *
     * @param e The encoding version to use to marshal request parameters.
     * @return A proxy with the specified encoding version.
     **/
    @Override
    default ServerPrx ice_encodingVersion(com.zeroc.Ice.EncodingVersion e) {
        return (ServerPrx) _ice_encodingVersion(e);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its endpoint selection policy.
     *
     * @param b If <code>b</code> is <code>true</code>, the new proxy will use secure endpoints for invocations
     *          and only use insecure endpoints if an invocation cannot be made via secure endpoints. If <code>b</code> is
     *          <code>false</code>, the proxy prefers insecure endpoints to secure ones.
     * @return A proxy with the specified selection policy.
     **/
    @Override
    default ServerPrx ice_preferSecure(boolean b) {
        return (ServerPrx) _ice_preferSecure(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the router.
     *
     * @param router The router for the new proxy.
     * @return A proxy with the specified router.
     **/
    @Override
    default ServerPrx ice_router(com.zeroc.Ice.RouterPrx router) {
        return (ServerPrx) _ice_router(router);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for the locator.
     *
     * @param locator The locator for the new proxy.
     * @return A proxy with the specified locator.
     **/
    @Override
    default ServerPrx ice_locator(com.zeroc.Ice.LocatorPrx locator) {
        return (ServerPrx) _ice_locator(locator);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for collocation optimization.
     *
     * @param b <code>true</code> if the new proxy enables collocation optimization; <code>false</code> otherwise.
     * @return A proxy with the specified collocation optimization.
     **/
    @Override
    default ServerPrx ice_collocationOptimized(boolean b) {
        return (ServerPrx) _ice_collocationOptimized(b);
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses twoway invocations.
     *
     * @return A proxy that uses twoway invocations.
     **/
    @Override
    default ServerPrx ice_twoway() {
        return (ServerPrx) _ice_twoway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses oneway invocations.
     *
     * @return A proxy that uses oneway invocations.
     **/
    @Override
    default ServerPrx ice_oneway() {
        return (ServerPrx) _ice_oneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch oneway invocations.
     *
     * @return A proxy that uses batch oneway invocations.
     **/
    @Override
    default ServerPrx ice_batchOneway() {
        return (ServerPrx) _ice_batchOneway();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses datagram invocations.
     *
     * @return A proxy that uses datagram invocations.
     **/
    @Override
    default ServerPrx ice_datagram() {
        return (ServerPrx) _ice_datagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, but uses batch datagram invocations.
     *
     * @return A proxy that uses batch datagram invocations.
     **/
    @Override
    default ServerPrx ice_batchDatagram() {
        return (ServerPrx) _ice_batchDatagram();
    }

    /**
     * Returns a proxy that is identical to this proxy, except for compression.
     *
     * @param co <code>true</code> enables compression for the new proxy; <code>false</code> disables compression.
     * @return A proxy with the specified compression setting.
     **/
    @Override
    default ServerPrx ice_compress(boolean co) {
        return (ServerPrx) _ice_compress(co);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection timeout setting.
     *
     * @param t The connection timeout for the proxy in milliseconds.
     * @return A proxy with the specified timeout.
     **/
    @Override
    default ServerPrx ice_timeout(int t) {
        return (ServerPrx) _ice_timeout(t);
    }

    /**
     * Returns a proxy that is identical to this proxy, except for its connection ID.
     *
     * @param connectionId The connection ID for the new proxy. An empty string removes the connection ID.
     * @return A proxy with the specified connection ID.
     **/
    @Override
    default ServerPrx ice_connectionId(String connectionId) {
        return (ServerPrx) _ice_connectionId(connectionId);
    }

    /**
     * Returns a proxy that is identical to this proxy, except it's a fixed proxy bound
     * the given connection.@param connection The fixed proxy connection.
     *
     * @return A fixed proxy bound to the given connection.
     **/
    @Override
    default ServerPrx ice_fixed(com.zeroc.Ice.Connection connection) {
        return (ServerPrx) _ice_fixed(connection);
    }

    static String ice_staticId() {
        return "::Murmur::Server";
    }
}
